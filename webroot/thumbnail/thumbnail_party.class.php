<?php
/**
 * thumbnail_party.class.php
 * Generate thumbnail from source image using GDlib or ImageMagick
 *
 * @author Mickey9801 <mickey9801@gmail.com>
 * @copyright copyright ComicParty.com 2006-2007
 * @version 1.1.9
 * @package thumbnail_party
 * 
 * DESCRIPTION :
 * This class provide an abstract interface to generate thumbnail
 * using GDlib or ImageMagick. You can decide the dimenision of
 * output thumbnail. The source image will be place inside the
 * thumbnail and resize in proportion based on the enlarge mode you
 * have chosen.
 *
 * Thumbnail can be output as file or send to output device directly
 *
 * If background color assigned, the background of output thumbnail
 * will be filled with color.
 * 
 * You can decide to enlarge source image when source image is
 * smaller the thumbnail, or remain unchange by setting enlarge mode.
 * If background color assigned and enlarge mode switched off,
 * the source image will be placed in the middle of thumbnail.
 * Otherwise, the thumnail will have same size as source image.
 *
 * Watermark feature has been added since v1.1.0
 *
 * The class will generate cache file to reduce work load
 *
 * When using GDlib, the class will also check PHP memory usage to
 * prevent error.
 *
 * Two types of error reporting machanism is provided in the class.
 * - When use with thumbnail.php (direct output to browser), an image
 * with error message will be generate when there is any error.
 * - When using the class alone, you may always keep track on any
 * error by calling isError() method.
 * 
 * INSTALL :
 * 1. Extract all files and folders from thumbnail_party.zip file
 * 2. Assign write permission to 'cache/' directory for all user.
 *    i.e. chmod 777 cache
 * 3. Include thumbnail_party.class.php to your code, or use with
 *    thumbnail.php to obtain the thumbnail directly
 *
 * EXAMPLE :
 * <?php
 * require('thumbnail_party.class.php');
 * $thumb =& new thumbnail_party($intWidth, $intHeight, '#RRGGBB', 'jpg');
 * if ($thumb->isError()) {
 *	die($thumb->get_error_msg());
 * }
 * // Set ImageMagick Path
 * if (!$thumb->set_imagemagick_path('/path/to/imagemagick/')) {
 * 	die($thumb->get_error_msg());
 * }
 * $thumb->intJPEGQuality = 85; // Assign picture quality for JPEG image
 *
 * // Set cache lifetime
 * // Set to 0 for cache never expire
 * $thumb->intCacheLifetime = 3600;
 *
 * // Setup Watermark
 * $thumb->set_watermark('sample/watermark.png', WATERMARK_POSITION_CENTER_RIGHT, 50)
 *
 * // Select enlarge mode for source image that smaller then output size
 * $thumb->set_enlarge_mode(THUMBNAIL_ENLARGE_ALWAYS);
 * // Set source image path
 * if (!$thumb->set_source_file($strFile)) die($thumb->get_error_msg());
 * 
 * // Output image to browser
 * if (!$thumb->output()) die($thumb->get_error_msg());
 * ?>
 *
 * For result of thumbnail generated by the class, please check
 * index.html
 * For usage of the class, please check thumbnail.php
 * 
 * USAGE :
 * To build thumbnail_party object :
 * $thumb =& thumbnail_party ($intWidth=100, $intHeight=100, $strColor=NULL, $strType='jpg', $strCacheDir=NULL)
 *
 * To assign a cache path :
 * set_cache_path ($strDir = NULL)
 * - If not provide a cache directory, by default will use 'cache/'. 
 *
 * To config ImageMagick Path :
 * set_imagemagick_path ($strIMPath = NULL)
 * -If you do not config this path, by default will use GDlib to
 *  manipulate image file
 *
 * To assign the source of thumbnail :
 * set_source_file ($strSourceFile)
 * - both absolute or relative path are acceptable
 *
 * To set image type of output image :
 * set_output_type ($strOutputType = 'jpg')
 * - possible values are 'jpg', 'jpeg, 'png', 'gif'
 *
 * To set output image size :
 * set_thumbnail_size ($intWidth = 100, $intHeight = 100)
 *
 * To set background color :
 * set_background ($strColor)
 * - format : '#RRGGBB' or 'RRGGBB'
 *
 * To add watermark
 * set_watermark ($strWatermarkPath, $intWatermarkPosition = WATERMARK_POSITION_RANDOM, $intWatermarkOpacity = 50)
 * - set to the watermark path to NULL for shutdown watermark feature
 * - possible value of watermark position are :
 *       WATERMARK_POSITION_TOP_LEFT
 *       WATERMARK_POSITION_TOP_MIDDLE
 *       WATERMARK_POSITION_TOP_RIGHT
 *       WATERMARK_POSITION_CENTER_LEFT
 *       WATERMARK_POSITION_CENTER_MIDDLE
 *       WATERMARK_POSITION_CENTER_RIGHT
 *       WATERMARK_POSITION_BOTTOM_LEFT
 *       WATERMARK_POSITION_BOTTOM_MIDDLE
 *       WATERMARK_POSITION_BOTTOM_RIGHT
 *       WATERMARK_POSITION_RANDOM
 *
 * To set enlarge mode
 * set_enlarge_mode ($intEnlargeMode)
 * - possible value : THUMBNAIL_ENLARGE_NONE(0) or THUMBNAIL_ENLARGE_ALWAYS(1)
 *
 * To output thumbnail to browser directly
 * output ()
 *
 * To output thumbnail to browser directly
 * output ('/path/and/filename/of/output/thumbnail')
 *
 * To check if the object is error on last operation
 * isError ()
 * - return TRUE when error found
 *
 * To obtain the last error message
 * get_error_msg ()
 *
 * HISTORY :
 * Mickey9801 2008-04-12 19:25 HKT
 *       Fix bug : fixed ImageMagick command bug when dealing with image path with space
 * Mickey9801 2007-08-3 14:15 HKT
 *       Fix bug : checking watermark object exists when source dimension same as destination dimension
 * Mickey9801 2007-07-21 12:30 HKT
 *       Add thumbnail_party::_trigger_error() method to simplify error triggering
 *       Add checking of cache directory ending slash
 * Mickey9801 2007-06-04 19:45 HKT
 *       Added cache lifetime
 * Mickey9801 2007-05-24 21:26 HKT
 *       Modified watermark setup procedure
 *       Modified error report method in constructor
 * Mickey9801 2006-12-18 13:04 HKT
 *       Add thumbnail_party::boolCache property to disable caching. To disable caching, just set boolCache proprety to FALSE
 * Mickey9801 2006-09-25 21:23 HKT
 *       Add _get_im_version() method for checking ImageMagick version internally.
 *       Disabled ImageMagick function if its version below v6.0.0
 *       Add get_version() method to return the version of Thumbnail Party
 * Mickey9801 2006-08-07 19:21 HKT
 *       Disable memory check for GDLib when memory_get_usage() is not avaliable. This may cause error when resize an image which total pixel is larger then 1/5 of memory avaliable. It is recommended to use ImageMagick to handle large image.
 * Mickey9801 2006-06-01 03:54 HKT
 *       Added Watermark feature and supplementary class tp_watermark
 *       According to watermark feature, arguments of set_imagemagick_path() change from file path to directory.
 *       Added image type 'image/x-png' to TP_ALLOWED_IMG_TYPE
 *       Centralized all output image calculation to _get_output_geometry() method
 * Mickey9801 2006-05-22 19:38 HKT
 *       Rename ALLOWED_IMG_TYPE to TP_ALLOWED_IMG_TYPE to prevent
 *       dependency
 *       Fixed set_background() does not return correctly bug
 *       Fixed some minor bugs
 * Mickey9801 2006-05-22 03:38 HKT
 *       First edition launched
 *
 */

define('THUMBNAIL_ENLARGE_NONE', 0);
define('THUMBNAIL_ENLARGE_ALWAYS', 1);
define('TP_ALLOWED_IMG_TYPE', 'image/jpeg,image/pjpeg,image/gif,image/png,image/x-png');
define('IMAGEMAGICK_RESIZE_CMD', '%sconvert -quality %d -resize %dx%d "%s" "%s"');
define('IMAGEMAGICK_RESIZE_FILLED_CMD', '%sconvert "%s" -quality %d -resize %dx%d -size %dx%d xc:%s +swap -gravity center -composite "%s"');
define('IMAGEMAGICK_WATERMARK_CMD', '%sconvert %s -gravity southeast -chop %dx%d png:- | %scomposite -geometry %s%s -dissolve %s%% png:- "%s" "%s"');

require_once(dirname(__FILE__).'/tp_watermark.class.php');

class thumbnail_party {
	var $strVersion = '1.1.9';
	var $strSourceFile;
	var $intThumbnailWidth;
	var $intThumbnailHeight;
	var $strBgColor = NULL;
	var $crop=NULL;
	var $strBgTransparent=NULL;
	var $strOutputType = 'jpg';
	var $intJPEGQuality = 100; // Picture quality for JPEG image. Max. value 100
	var $boolCache = TRUE; // use caching
	var $intCacheLifetime = 3600; // cache lifetime in secord, 0 for never expire
	var $strCacheDir = '../../tmp/';
	var $strImageMagicPath = NULL; // Path to ImageMagick. Usually is '/usr/bin/' or '/usr/local/bin/'
	var $intEnlargeMode = THUMBNAIL_ENLARGE_NONE; // by default, keep the source in original size if the source smaller then output size (no enlarge)
	var $objWatermark = NULL;
	var $boolError = FALSE; 
	var $strErrMsg = '';
	
	/**
	 * Constructor
	 *
	 * @param integer $intWidth Thumbnail width. Default 100.
	 * @param integer $intHeight Thumbnail height. Default 100.
	 * @param string $strColor Color string. Possible format : '#RRGGBB' & 'RRGGBB', Default NULL
	 * @param string $strType Thumbnail Type. Possible value : 'jpg', 'jpeg', 'gif' & 'png'. Default 'jpg'
	 * @param string $strCacheDir Cache path. Default NULL means using class default path 'cache/'
	 * @return void
	 * @access public
	 */
	function thumbnail_party ($intWidth=100, $intHeight=100, $strColor=NULL, $strType='jpg', $strCacheDir=NULL) {
		$this->intThumbnailWidth = $intWidth;
		$this->intThumbnailHeight = $intHeight;
		$this->set_background($strColor);
		$this->set_output_type($strType);
		if (!empty($strCacheDir)) {
			$this->set_cache_path($strCacheDir);
		}
	}
	
	/**
	 * Return the version of Thumbnail Party
	 *
	 * @return string version string
	 * @access public
	 */
	function get_version () {
		return $this->strVersion;
	}
	
	/**
	 * To set cache path
	 *
	 * @param string $strDir Path to cache directory. 
	 * @return boolean true when the cache directory avaliable
	 * @access public
	 */
	function set_cache_path ($strDir) {
		$this->_clear_error();
		if (substr($strDir, -1, 1) != '/') $strDir .= '/';
		if (is_writable($strDir)) {
			$this->strCacheDir = $strDir;
			return TRUE;
		} else {
			return $this->_trigger_error('Cache directory is not present or unable to write');
		}
	}
	
	/**
	 * To set ImageMagick path
	 *
	 * @param string $strIMPath Path to ImageMagick. Usually are '/usr/bin/' or '/usr/local/bin/'. Set to NULL of using GDlib
	 * @return boolean true when the ImageMagick is avaliable
	 * @access public
	 */
	function set_imagemagick_path ($strIMPath = NULL) {
		$this->_clear_error();
		if (empty($strIMPath) || file_exists($strIMPath)) {
			// check submitted argument is a file or a directory for backward compatible.
			if (!is_file($strIMPath)) $this->strImageMagicPath = $strIMPath;
			elseif (is_dir($strIMPath)) $this->strImageMagicPath = dirname($strIMPath).'/';
			return TRUE;
		} else {
			return $this->_trigger_error('Invalid ImageMagick path');
		}
	}
	
	/**
	 * Assign source image path
	 *
	 * @param string $strSourceFile Path and filename of source image
	 * @return boolean true when the source is avaliable
	 * @access public
	 */
	function set_source_file ($strSourceFile) {
		$this->_clear_error();
		//if (trim($strSourceFile) != '' && file_exists($strSourceFile)) {
			if (trim($strSourceFile) != '' ) {
			$this->strSourceFile = $strSourceFile;
			return TRUE;
		} else {
			return $this->_trigger_error('Invalid source image ('.$strSourceFile.')');
		}
	}
	
	/**
	 * To set thumbnail type
	 *
	 * @param string $strOutType Possible value : 'jpg', 'jpeg', 'gif' and 'png'. Default 'jpg'
	 * @return boolean true when assigned value is correct.
	 * @access public
	 */
	function set_output_type($strOutputType = 'jpg') {
		$this->_clear_error();
		$strOutputType = strtolower($strOutputType);
		if ($strOutputType=='jpg' || $strOutputType=='jpeg' || $strOutputType=='gif' || $strOutputType=='png') {
			$this->strOutputType = $strOutputType;
			return TRUE;
		} else {
			return $this->_trigger_error('Invalid output image type');
		}
	}

	/**
	 * To set thumbnail side
	 *
	 * @param integer $intWidth Thumbnail width. Default 100px
	 * @param integer $intHeight Thumbnail height. Default 100px
	 * @return void
	 * @access public
	 */
	function set_thumbnail_size($intWidth = 100, $intHeight = 100) {
		$this->intThumbnailWidth = $intWidth;
		$this->intThumbnailHeight = $intHeight;
	}
	
	/**
	 * To set thumbnail background color
	 * If background color is set. The shorter side will be filled with this color 
	 * 
	 * @param string $strColor Color string. Possible format : '#RRGGBB' & 'RRGGBB', Default NULL
	 * @return boolean when the color string is incorrect
	 * @access public
	 */
	function set_background($strColor) {
		$this->_clear_error();
		if (empty($strColor)) $this->strBgColor = NULL;
		elseif (strlen($strColor)==6) $this->strBgColor = '#'.$strColor;
		elseif (strlen($strColor)==7 && substr($strColor, 0, 1)=='#') $this->strBgColor = $strColor;
		else {
			return $this->_trigger_error('Invalid color. (Format: #RRGGBB or RRGGBB)');
		}
		return TRUE;
	}
	
	/**
	 * Set Watermark file path
	 * Set to NULL for shutdown watermark feature
	 *
	 * @param string $strWatermarkPath path and filename to watermark image
	 * @param integer $intWatermarkPosition position of watermark image will be placed in
	 * @param integer $intWatermarkOpacity opacity of the watermark
	 * @return boolean true if watermark object built-up successfully
	 * @access public
	 */
	function set_watermark ($strWatermarkPath=NULL, $intWatermarkPosition=WATERMARK_POSITION_RANDOM, $intWatermarkOpacity=50) {
		$this->_clear_error();
		if ($strWatermarkPath == NULL) {
			$this->objWatermark = NULL;
			return TRUE;
		}
		$this->objWatermark =new tp_watermark($strWatermarkPath);
		if (!$this->objWatermark->boolError) {
			$this->objWatermark->set_position((int)$intWatermarkPosition);
			$this->objWatermark->set_opacity((int)$intWatermarkOpacity);
			return TRUE;
		} else {
			$this->objWatermark = NULL;
			return $this->_trigger_error('Cannot obtain watermark object');
		}
	}
		
	/**
	 * To set the enlarge mode
	 * If enlarge mode set to THUMBNAIL_ENLARGE_NONE(0),
	 * source will not be enlarged when the source size smaller then output size,
	 * and all space will fill with background color
	 * If enlarge mode set to THUMBNAIL_ENLARGE_ALWAYS(1),
	 * source will be enlarged to max output size.
	 * Fill mode is not applicable if no background color assigned.
	 *
	 * @param integer $intEnlargeMode Possible value : THUMBNAIL_ENLARGE_NONE(0) and THUMBNAIL_ENLARGE_ALWAYS(1)
	 * @return void
	 * @access public
	 */
	function set_enlarge_mode ($intEnlargeMode) {
		$this->intEnlargeMode = (int)$intEnlargeMode;
	}
	
	/**
	 * Output thumbnail
	 *
	 * @param string $strDest Path and filename of output file. If not provided, thumbnail will output to browser directly
	 * @return boolean true when done
	 * @access public
	 */
	function output($strDest = NULL) {
		$this->_clear_error();
		
		if (!empty($this->strSourceFile)) {
			// check the version of ImageMagick
			if (!empty($this->strImageMagicPath)) {
				$arrVersion = $this->_get_im_version();
				if ($arrVersion[1] < 6) $this->strImageMagicPath = NULL; // Disable ImageMagick feature if its version below 6
			}
			
			// obtain source information
			// and check enlarge mode
			$arrSourceInfo = getimagesize($this->strSourceFile);
			
			if (
				$this->intEnlargeMode==THUMBNAIL_ENLARGE_NONE && 
				empty($this->strBgColor) && 
				$arrSourceInfo[0] < $this->intThumbnailWidth && 
				$arrSourceInfo[1] < $this->intThumbnailHeight
			) {
				$this->intThumbnailWidth = $arrSourceInfo[0];
				$this->intThumbnailHeight = $arrSourceInfo[1];
			}
			
			// generate a thumbnail cache key
			$strThumbnailKey = md5_file($this->strSourceFile);
			$strThumbnailKey = md5( $this->intThumbnailWidth."x".$this->intThumbnailHeight."_".
						((!empty($this->strImageMagicPath))?$this->strImageMagicPath."_":"").
						(($this->strOutputType=='jpg' || $this->strOutputType=='jpeg')?$this->intJPEGQuality."_":"").
						((!empty($this->strBgColor))?$this->strBgColor."_":"").
						$this->intEnlargeMode."_".
						$strThumbnailKey.
						(($this->objWatermark!=NULL)?md5_file($this->objWatermark->strWatermarkPath)."_":"") );
			$strCacheImageFile = "thumbnail_".$strThumbnailKey.".".$this->strOutputType;
			$strCacheImagePath = $this->strCacheDir.$strCacheImageFile;
			
			// if source is smaller then target, no enlarge, no background,
			// output type is same as source type and not found same cache
			// simply copy the source with cache name
			if (
				$this->intThumbnailWidth == $arrSourceInfo[0] && 
				$this->intThumbnailHeight == $arrSourceInfo[1] && 
				$arrSourceInfo['mime'] == $this->_output_type2mime() && 
				empty($this->objWatermark)
			) {
				if (!file_exists($strCacheImagePath)) {
					copy($this->strSourceFile, $strCacheImagePath);
				}
			}
			
			// Check cache
			if (
				file_exists($strCacheImagePath) &&
				(
					$this->intCacheLifetime == 0 ||
					$this->intCacheLifetime > (time()-filemtime($strCacheImagePath))
				)
			) { // Cache found and not expire, use cache.
				if (empty($strDest)) { // Output to display
					$this->_send_image_header();
					readfile($strCacheImagePath);
					return TRUE;
				} else {
					copy ($strCacheImagePath, $strDest);
					return TRUE;
				}
			} else { // No cache, generate a new thumbnail
				// if ImageMagick found, always use ImageMagick
				if (!empty($this->strImageMagicPath)) {
					$boolResult = $this->_imagemagick_output($arrSourceInfo, $strCacheImagePath, $strDest);
					return $boolResult;
				} else { // no ImageMagick, use GD2
					$boolResult = $this->_gd_output($arrSourceInfo, $strCacheImagePath, $strDest);
					return $boolResult;
				}
			}
		} else {
			return $this->_trigger_error('Invalid source image : '.$this->strSourceFile);
		}
	}
	
//================ Private method
	/**
	 * Output HTTP header
	 *
	 * @return void
	 * @access protected
	 */
	function _send_image_header () {
		header ("Content-Type: " . $this->_output_type2mime());
		header ("Last-Modified: " . gmdate('D, d M Y H:i:s \G\M\T', time()));
		header ("Expires: Thu, 01 Jan 1970 08:00:00 GMT");
		header ("Accept-Ranges: bytes");
		header ('Pragma: no-cache');
		header ('Cache-Control: no-store, no-cache, must-revalidate');
		header ('Cache-Control: pre-check=0, post-check=0, max-age=0', FALSE);
		return;
	}
	
	/**
	 * ImageMagick output method
	 *
	 * @param array $arrSourceInfo Source image infomation including file size and file type
	 * @param string $strCacheImagePath Path and filename of cache file will be saved
	 * @param string $strDest Path and filename for saving the thumbnail. If not provided, thumbnail will output to browser directly
	 * @return boolean true when done
	 * @access protected
	 */
	function _imagemagick_output (&$arrSourceInfo, &$strCacheImagePath, $strDest=NULL) {
		if (
			$this->intThumbnailWidth==$arrSourceInfo[0] && 
			$this->intThumbnailHeight==$arrSourceInfo[1] 
		) {
			// convert source file to target image type, with cache name
			$strCmd = $this->strImageMagicPath."convert ".$this->strSourceFile." ".$strCacheImagePath;
		} else {
			if (empty($this->strBgColor)) { // no fill
				// resize source
				$strCmd = sprintf(IMAGEMAGICK_RESIZE_CMD, $this->strImageMagicPath, $this->intJPEGQuality, $this->intThumbnailWidth, $this->intThumbnailHeight, $this->strSourceFile, $strCacheImagePath);
			} else { // fill background
				if (
					$this->intEnlargeMode==THUMBNAIL_ENLARGE_ALWAYS || 
					$arrSourceInfo[0] > $this->intThumbnailWidth || 
					$arrSourceInfo[1] > $this->intThumbnailHeight
				) {
					// resize source with background
					$strCmd = sprintf(
						IMAGEMAGICK_RESIZE_FILLED_CMD,
						$this->strImageMagicPath,
						$this->strSourceFile,
						$this->intJPEGQuality,
						$this->intThumbnailWidth,
						$this->intThumbnailHeight,
						$this->intThumbnailWidth,
						$this->intThumbnailHeight,
						$this->strBgColor,
						$strCacheImagePath
					);
				} else {
					// place the source file in the middle of canvas
					$strCmd = sprintf(
						IMAGEMAGICK_RESIZE_FILLED_CMD,
						$this->strImageMagicPath,
						$this->strSourceFile,
						$this->intJPEGQuality,
						$arrSourceInfo[0],
						$arrSourceInfo[1],
						$this->intThumbnailWidth,
						$this->intThumbnailHeight,
						$this->strBgColor,
						$strCacheImagePath
					);
				}
			}
		}
		
		// watermark
		if ($this->objWatermark != NULL) {
			$arrOutputGeometry = $this->_get_output_geometry($arrSourceInfo);
			$this->objWatermark->get_geometry($arrOutputGeometry);
			$strCmd .= '; '.sprintf(
				IMAGEMAGICK_WATERMARK_CMD,
				$this->strImageMagicPath,
				$this->objWatermark->strWatermarkPath,
				$this->objWatermark->intChopAreaWidth,
				$this->objWatermark->intChopAreaHeight,
				$this->strImageMagicPath,
				$this->objWatermark->intX,
				$this->objWatermark->intY,
				$this->objWatermark->intOpacity,
				$strCacheImagePath,
				$strCacheImagePath);
		}
		
		// execute imagemagick command
		$strExecResult = exec ($strCmd, $output, $retval);
		if ($retval)  {
			return $this->_trigger_error('ERROR : ImageMagick met error : '.$strCmd);
		}
		
		if (empty($strDest)) { // Output to display
			$this->_send_image_header();
			readfile($strCacheImagePath);
			return TRUE;
		} else { // Copy cache file to target directory
			copy ($strCacheImagePath, $strDest);
			return TRUE;
		}
	}
	
	/**
	 * GDlib output method
	 *
	 * @param array $arrSourceInfo Source image infomation including file size and file type
	 * @param string $strCacheImagePath Path and filename of cache file will be saved
	 * @param string $strDest Path and filename for saving the thumbnail. If not provided, thumbnail will output to browser directly
	 * @return boolean true when done
	 * @access protected
	 */
	function _gd_output (&$arrSourceInfo, &$strCacheImagePath, $strDest=NULL) {
		/*if (strpos(TP_ALLOWED_IMG_TYPE, $arrSourceInfo['mime'])===FALSE) {
			return $this->_trigger_error('Source file unsupported by GDlib');
		}*/
		
		// Calculate the total pixel
		// Check for GD limit : total_pixel <= memory_usable/5
		// Fixed : disable memory test when memory_get_usage() is not avaliable.
		$intSourceTotalPixel = $arrSourceInfo[0]*$arrSourceInfo[1];
		if (function_exists('memory_get_usage')) {
			$intMemoryAvaliable = $this->_return_bytes(ini_get('memory_limit')) - memory_get_usage();
		} else { // Assume you have enough memory... good luck...
			$intMemoryAvaliable = $intSourceTotalPixel * 6;
		}
		if ($intMemoryAvaliable > $intSourceTotalPixel * 5) {
			switch($arrSourceInfo['mime'])
			{
				case 'image/jpeg' :
				case 'image/pjpeg' :
					$resInputImg = @imagecreatefromjpeg($this->strSourceFile);
					break;
				case 'image/gif' :
					$resInputImg = @imagecreatefromgif($this->strSourceFile);
					break;
				case 'image/png' :
				case 'image/x-png' :
					$resInputImg = @imagecreatefrompng($this->strSourceFile);
					break;
				default :
					return $this->_trigger_error('Invalid output image type');
					break;
			}
			
			if ($resInputImg) {
				// obtain color's hex value
				if (!empty($this->strBgColor)) {
					$hexFillColor = '0x'.substr($this->strBgColor, 1, 6);
					eval("\$hexFillColor = ".$hexFillColor.";");
				}
				
				// obtain output position and size
				$arrOutputGeometry = $this->_get_output_geometry($arrSourceInfo);
				
				// Place source image on canvas
				//if ($arrOutputGeometry['intCanvasWidth'] * $arrOutputGeometry['intCanvasHeight'] * 5 < $intMemoryAvaliable) {
					$resCanvas = imagecreatetruecolor($arrOutputGeometry['intCanvasWidth'], $arrOutputGeometry['intCanvasHeight']);
					imagesavealpha($resCanvas, true);
					//imagecolortransparent($resCanvas);
			//	} else {
				//	return $this->_trigger_error('Output image over size. (Max. number of pixel allowed : '.floor($intMemoryAvaliable/5).')');
				//}
				/*if(!empty($this->strBgTransparent))
				{
					 $trans_colour = imagecolorallocatealpha($resCanvas, 0, 0, 0, 127);
    			imagefill($resCanvas, 0, 0, $trans_colour);
				}
				else*/

				if (!empty($this->strBgColor)) 
				{
				//	 $color = imagecolorallocatealpha($resCanvas, 255, 255, 255,127);
				 //   imagefilledrectangle($resCanvas, 0, 0, imagesx($resCanvas), imagesy($resCanvas), $color);
				imagefill($resCanvas, 0, 0, $hexFillColor);
				}
				
				
				
			
					
			
				if(!empty($this->crop))
				{
					$ra=$arrSourceInfo[0]/$arrSourceInfo[1];
					$wi=$arrOutputGeometry['intCanvasWidth'];
					$hi=$arrOutputGeometry['intCanvasHeight']/$ra;
					if($hi<$arrOutputGeometry['intCanvasHeight'])
					{
						$wi=$ra*$arrOutputGeometry['intCanvasHeight'];
						$hi=$arrOutputGeometry['intCanvasHeight'];
					}
					$x=0;
					$y=0;
					
					if($arrOutputGeometry['intCanvasWidth']!=$arrOutputGeometry['intCanvasHeight'])
					{
						$width=$arrSourceInfo[0];
						$height=$arrSourceInfo[1];
						$crop=array($arrOutputGeometry['intCanvasWidth'],$arrOutputGeometry['intCanvasHeight']);
						$image=$resInputImg;
					    $ratio = array
								(
										0 => $width / $height,
										1 => $crop[0] / $crop[1],
								);
				
								if ($ratio[0] > $ratio[1])
								{
										$width = $height * $ratio[1];
										$x = (imagesx($image) - $width) / 2;
								}
				
								else if ($ratio[0] < $ratio[1])
								{
										$height = $width / $ratio[1];
										$y = (imagesy($image) - $height) / 2;
								}
								 $result = imagecreatetruecolor($crop[0], $crop[1]);

								if (is_resource($result) === true)
								{
										imagesavealpha($result, true);
										imagealphablending($result, false);
										imagefill($result, 0, 0, imagecolorallocatealpha($result, 255, 255, 255, 127));
				
										imagecopyresampled($result, $image, 0, 0, $x, $y, $crop[0], $crop[1], $width, $height);
				
										$resCanvas = $result;
									
								}
					}
					else
					{	
					$resCanvas1 = imagecreatetruecolor($wi, $hi);
					imagesavealpha($resCanvas1, true);
					$trans_colour = imagecolorallocatealpha($resCanvas1, 0, 0, 0, 127);
    				imagefill($resCanvas1, 0, 0, $trans_colour);
					
				
					imagecopyresampled(
					$resCanvas1,
					$resInputImg,
					0,
					0,
					$x,
					$y,
					round($wi),
					round($hi),
					$arrSourceInfo[0],
					$arrSourceInfo[1]
				);
				
				
					$wpad = 0;
					$hpad = 0;
					if($wi > $hi)
					$wpad = round(($wi - $hi)/2);
					elseif($wi < $hi)
					$hpad = round(($hi- $wi)/2);
					
				
					$resInputImg=$resCanvas1;
					imagecopyresampled(
					$resCanvas,
					$resInputImg,
					0,
					0,
					$wpad,
					$hpad,
					round($arrOutputGeometry['intCanvasWidth']),
					round($arrOutputGeometry['intCanvasHeight']), 
					round($arrOutputGeometry['intCanvasWidth']),
					round($arrOutputGeometry['intCanvasHeight'])
					);
					}
				}
				else
				{
				imagecopyresampled(
					$resCanvas,
					$resInputImg,
					$arrOutputGeometry['intOutputX'],
					$arrOutputGeometry['intOutputY'],
					0,
					0,
					round($arrOutputGeometry['dblOutputWidth']),
					round($arrOutputGeometry['dblOutputHeight']),
					$arrSourceInfo[0],
					$arrSourceInfo[1]
				);
				}
				// watermark
				if ($this->objWatermark != NULL) {
					$this->objWatermark->get_geometry($arrOutputGeometry);
					$resWatermarkImg = @imagecreatefrompng($this->objWatermark->strWatermarkPath);
					imagecopymerge(
						$resCanvas,
						$resWatermarkImg,
						$this->objWatermark->intX,
						$this->objWatermark->intY,
						0,
						0,
						$this->objWatermark->intChoppedWidth,
						$this->objWatermark->intChoppedHeight,
						$this->objWatermark->intOpacity
					);
				}
				//$boolResult = imagepng($resCanvas, $strCacheImagePath);
				// output image
				switch ($this->strOutputType) {
					case 'gif' :
						$boolResult = imagegif($resCanvas, $strCacheImagePath);
						break;
					case 'png' :
						$boolResult = imagepng($resCanvas, $strCacheImagePath);
						break;
					case 'jpg' :
					case 'jpeg' :
					default :
						$boolResult = imagejpeg($resCanvas, $strCacheImagePath, $this->intJPEGQuality);
						break;
				}
				if ($boolResult) {
					if (empty($strDest)) { // send cache to output device
						$this->_send_image_header();
						readfile($strCacheImagePath);
					} else { // write cache to file
						copy($strCacheImagePath, $strDest);
					}
					imagedestroy($resInputImg);
					imagedestroy($resCanvas);
					return TRUE;
				} else {
					if ($resInputImg) imagedestroy($resInputImg);
					if ($resCanvas) imagedestroy($resCanvas);
					return $this->_trigger_error('GD export image failed');
				}
			}
		} else { // Over memory limit, throw an exception
			return $this->_trigger_error('Source over size. (Max. number of pixel allowed : '.floor($intMemoryAvaliable/5).')');
		}
	}
	
	/**
	 * Convert image type to mime type string
	 *
	 * @param string $strImageType Image type string. Use native image type when no prarmeter
	 * @return string MIME type
	 * @access protected
	 */
	function _output_type2mime ($strImageType=NULL) {
		if (empty($strImageType)) $strImageType = &$this->strOutputType;
		switch ($strImageType) {
			case 'gif' :
				return 'image/gif';
				break;
			case 'png' :
				return 'image/png';
				break;
			case 'jpg' :
			case 'jpeg' :
			default :
				return 'image/jpeg';
				break;
		}
	}
	
	/**
	 * Convert shorten form file size to byte
	 * Original from PHP.NET
	 *
	 * @param string $strVal Human readable file size string
	 * @return integer Byte value
	 * @access protected
	 */
	function _return_bytes($strVal) {
	   $strVal = str_replace(" ", "", trim($strVal));
	   preg_match("/[a-zA-Z]{1,2}/", $strVal, $match);
	   $unit = (isset($match[0])) ? strtolower($match[0]) : "";
	   $amount = (float)str_replace($unit, "", $strVal);
	   switch($unit) {
	       // The 'G' modifier is available since PHP 5.1.0
	       case 't':
	       case 'tb':
	           $amount *= 1024;
	       case 'g':
	       case 'gb':
	           $amount *= 1024;
	       case 'm':
	       case 'mb':
	           $amount *= 1024;
	       case 'k':
	       case 'kb':
	           $amount *= 1024;
	   }
	
	   return round($amount);
	}
	
  /**
   * get output position and size
   *
   * @param array $arrSourceInfo source image dimension
   * @return array $arrOutputGeometry output file size, coordinate and canvas size
   * @access protected
   */
  function _get_output_geometry (&$arrSourceInfo) {
		$arrOutputGeometry = array();
		if (
			$this->intThumbnailWidth==$arrSourceInfo[0] && 
			$this->intThumbnailHeight==$arrSourceInfo[1]
		) {
			// Source smaller then canvas and no background
			// convert source file to target image type, with cache name
			$arrOutputGeometry['intCanvasWidth'] = $arrSourceInfo[0];
			$arrOutputGeometry['intCanvasHeight'] = $arrSourceInfo[1];
			$arrOutputGeometry['intOutputX'] = 0;
			$arrOutputGeometry['intOutputY'] = 0;
			$arrOutputGeometry['dblOutputWidth'] = $arrSourceInfo[0];
			$arrOutputGeometry['dblOutputHeight'] = $arrSourceInfo[1];
		} else {
			$arrOutputGeometry['intCanvasWidth'] = $this->intThumbnailWidth;
			$arrOutputGeometry['intCanvasHeight'] = $this->intThumbnailHeight;
			$dblWidthRatio = $arrSourceInfo[0] / $arrOutputGeometry['intCanvasWidth'];
			$dblHeightRatio = $arrSourceInfo[1] / $arrOutputGeometry['intCanvasHeight'];
			if (
				$this->intEnlargeMode==THUMBNAIL_ENLARGE_NONE && 
				(($arrSourceInfo[0] < $arrOutputGeometry['intCanvasWidth']) && ($arrSourceInfo[1] < $arrOutputGeometry['intCanvasHeight']))
			) {
				// place the source file in the middle of canvas
				$arrOutputGeometry['intOutputX'] = round(($arrOutputGeometry['intCanvasWidth'] - $arrSourceInfo[0]) / 2);
				$arrOutputGeometry['intOutputY'] = round(($arrOutputGeometry['intCanvasHeight'] - $arrSourceInfo[1]) / 2);
				$arrOutputGeometry['dblOutputWidth'] = $arrSourceInfo[0];
				$arrOutputGeometry['dblOutputHeight'] = $arrSourceInfo[1];
			} elseif ($dblWidthRatio > $dblHeightRatio) {
				$arrOutputGeometry['intOutputX'] = 0;
				$dblHeightRatio = $arrSourceInfo[1] / $arrSourceInfo[0] * ($arrOutputGeometry['intCanvasWidth'] / $arrOutputGeometry['intCanvasHeight']);
				if (!empty($this->strBgColor)) {
					$arrOutputGeometry['intOutputY'] = round(($arrOutputGeometry['intCanvasHeight'] - ($dblHeightRatio * $arrOutputGeometry['intCanvasHeight'])) / 2);
				} else $arrOutputGeometry['intOutputY'] = 0;
				$arrOutputGeometry['dblOutputWidth'] = $arrOutputGeometry['intCanvasWidth'];
				$arrOutputGeometry['dblOutputHeight'] = $arrOutputGeometry['intCanvasHeight'] * $dblHeightRatio;
			} else {
				$dblWidthRatio = $arrSourceInfo[0] / $arrSourceInfo[1] * ($arrOutputGeometry['intCanvasHeight'] / $arrOutputGeometry['intCanvasWidth']);
				if (!empty($this->strBgColor)) {
					$arrOutputGeometry['intOutputX'] = ceil(($arrOutputGeometry['intCanvasWidth'] - ($dblWidthRatio * $arrOutputGeometry['intCanvasWidth'])) / 2);
				} else $arrOutputGeometry['intOutputX'] = 0;
				$arrOutputGeometry['intOutputY'] = 0;
				$arrOutputGeometry['dblOutputWidth'] = $arrOutputGeometry['intCanvasWidth'] * $dblWidthRatio;
				$arrOutputGeometry['dblOutputHeight'] = $arrOutputGeometry['intCanvasHeight'];
			}
			
			if (empty($this->strBgColor)) {
				$arrOutputGeometry['intCanvasWidth'] = round($arrOutputGeometry['dblOutputWidth']);
				$arrOutputGeometry['intCanvasHeight'] = round($arrOutputGeometry['dblOutputHeight']);
			}
		}
  	return $arrOutputGeometry;
  }
  
	/**
	 * Obtain the version of ImageMagick
	 *
	 * @return array containing 3 elements : [0]-Version string, [1]-Major version, [2]-Subversion, [3]-Minor version
	 * @return boolean false if fail or ImageMagick unavailable
	 * @access protected
	 */
  function _get_im_version () {
  	if (empty($this->strImageMagicPath)) return FALSE;
		exec($this->strImageMagicPath.'convert -version', $arrOutput, $intReturnVar);
		if ($intReturnVar || empty($arrOutput[0])) return FALSE;
		$arrReturn = array();
		preg_match('/^Version:\sImageMagick\s([0-9.]*)\s.*/', $arrOutput[0], $arrMatch);
		$arrReturn[0] = $arrMatch[1];
		$arrVersion = explode('.', $arrMatch[1]);
		$arrReturn[1] = (int)$arrVersion[0];
		$arrReturn[2] = (int)$arrVersion[1];
		$arrReturn[3] = (int)$arrVersion[2];
		return $arrReturn;
  }
  
  
//================ Method for error reporting
	/**
	 * Obtain error status of the class
	 *
	 * @return boolean true if there is any error
	 * @access public
	 */
	function isError () {
		return $this->boolError;
	}
	
	/**
	 * Obtain last error message
	 *
	 * @return string Error message
	 * @access public
	 */
	function get_error_msg () {
		return $this->strErrMsg;
	}
	
	/**
	 * Wrapper for triggering error
	 *
	 * @param  string    $strErrorMsg  Error message
	 * @return boolean   Always return FALSE
	 * @access protected
	 */
	function _trigger_error ($strErrorMsg) {
		$this->boolError = TRUE;
		$this->strErrMsg = $strErrorMsg;
		return FALSE;
	}
	
	/**
	 *  error status and error message
	 *
	 * @return void
	 * @access protected
	 */
	function _clear_error () {
		$this->boolError = FALSE;
		$this->strErrMsg = '';
	}
	
	/**
	 * To print some message on picture for debug
	 *
	 * @param resource $resImg The image resource that the message will be placed in.
	 * @param string $strMsg The message
	 * @return void
	 * @access protected
	 */
	function _gd_print_msg (&$resImg, $strMsg) {
		$arrMsg = explode("\n", wordwrap($strMsg,15,"\n",TRUE));
		for ($i=0; $i < count($arrMsg); $i++) {
			imagestring($resImg, 2, 1, $i*12+1, $arrMsg[$i], 0xFFFFFF);
			imagestring($resImg, 2, 0, $i*12, $arrMsg[$i], 0xFF0000);
		}
	}
}
?>